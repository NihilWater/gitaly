package git

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"time"

	"github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus/ctxlogrus"
	"github.com/opentracing/opentracing-go"
	"github.com/uber/jaeger-client-go"
	"gitlab.com/gitlab-org/gitaly/v15/internal/metadata/featureflag"
	"gitlab.com/gitlab-org/labkit/correlation"
	"go.opencensus.io/trace"
)

// trace2Event is used to deserialize the data generated by GIT_TRACE2
type trace2Event struct {
	Event   string    `json:"event"`
	Sid     string    `json:"sid"`
	Thread  string    `json:"thread"`
	Time    time.Time `json:"time"`
	File    string    `json:"file"`
	Line    int       `json:"line"`
	AbsTime float64   `json:"t_abs"`
	Code    int       `json:"code"`
}

// enableTrace2 will prepare the environment to send Git TRACE2 events to
// opentracing. It return a slice of environment variables that need to be
// injected into the Command, and a finish function that needs to be called when
// the command is done.
func enableTrace2(ctx context.Context, span opentracing.Span) ([]string, func(), error) {
	if !isTracingEnabled(ctx, span) {
		return []string{}, func() {}, nil
	}

	tmpFile, err := os.CreateTemp("", "gitaly-trace2.")
	if err != nil {
		return nil, nil, fmt.Errorf("Trace2 create tempfile: %w", err)
	}

	env := []string{
		fmt.Sprintf("GIT_TRACE2_EVENT=%v", tmpFile.Name()),
		fmt.Sprintf("GIT_TRACE2_PARENT_SID=%s", correlation.ExtractFromContextOrGenerate(ctx)),
	}

	finish := func() {
		dec := json.NewDecoder(tmpFile)
		var ev trace2Event

		for {
			err := dec.Decode(&ev)
			if err == nil {
				span.LogKV(
					"trace2.event", ev.Event,
					"trace2.sid", ev.Sid,
					"trace2.thread", ev.Thread,
					"trace2.time", ev.Time,
					"trace2.file", ev.File,
					"trace2.line", ev.Line,
					"trace2.t_abs", ev.AbsTime,
					"trace2.code", ev.Code)
			} else if errors.Is(err, io.EOF) {
				break
			} else {
				log.Println("the error %w", err)
				break
			}
		}

		if err := tmpFile.Close(); err != nil {
			ctxlogrus.Extract(ctx).WithError(err).Error("failed to close TRACE2 temp file")
		}
		if err := os.Remove(tmpFile.Name()); err != nil {
			ctxlogrus.Extract(ctx).WithError(err).Error("failed to remove TRACE2 temp file")
		}
	}

	return env, finish, nil
}

func isTracingEnabled(ctx context.Context, span opentracing.Span) bool {
	// Only when the feature flag is enabled
	if featureflag.GitTrace2.IsDisabled(ctx) {
		return false
	}

	// No tracer registered
	if _, ok := span.Tracer().(opentracing.NoopTracer); ok {
		return false
	}

	// Jaeger is only used in local development
	if _, ok := span.Tracer().(*jaeger.Tracer); ok {
		return true
	}

	// Only enable TRACE2 if context is actively sampled
	// Taken from https://gitlab.com/gitlab-org/labkit/-/blob/959b71911822d1c6cc1c2ef3bccf844d814066d6/tracing/impl/stackdriver_tracer.go#L77
	// return trace.FromContext(ctx).SpanContext().IsSampled()
	return trace.FromContext(ctx).IsRecordingEvents()
}
